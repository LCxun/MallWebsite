var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { createBrowserHistory } from "history";
export { createBrowserHistory, createHashHistory, createMemoryHistory } from "history";
import { compose, EventEmitter, warningOnce, joinPaths, stripBasename, isNil, matchRoutes, resolveTo } from "oh-router-shared";
class Middleware {
  register(ctx) {
    return true;
  }
}
class RouterMiddleware {
  constructor(middlewares = []) {
    __publicField(this, "middlewares", []);
    this.middlewares = middlewares || [];
  }
  addMiddleware(middlewares) {
    middlewares = Array.isArray(middlewares) ? middlewares : [middlewares];
    this.middlewares.push(...middlewares);
    return this;
  }
  async execMiddlewares(ctx, middlewares) {
    const fn = compose(middlewares.map((m) => {
      return async function(ctx2, next) {
        if (m.register(ctx2)) {
          m.handler(ctx2, next);
        } else {
          next();
        }
      };
    }));
    return fn(ctx);
  }
}
class Router extends RouterMiddleware {
  constructor(opts) {
    super(opts.middlewares);
    __publicField(this, "routes");
    __publicField(this, "history");
    __publicField(this, "basename");
    __publicField(this, "lastHistoryUpdate");
    __publicField(this, "location");
    __publicField(this, "event", new EventEmitter());
    this.routes = opts.routes;
    this.basename = opts.basename || "/";
    this.history = opts.history || createBrowserHistory();
    return this;
  }
  start() {
    if (this.lastHistoryUpdate)
      return this;
    this.history.listen(this.onHistoryLocationChange.bind(this));
    this.onHistoryLocationChange({
      action: this.history.action,
      location: this.history.location
    });
    return this;
  }
  async onHistoryLocationChange(update, force = false) {
    var _a;
    warningOnce("basename", !(this.basename !== "/" && update.location.pathname === "/"), "maybe you should navigate to " + this.basename);
    if (this.lastHistoryUpdate && !force) {
      if (joinPaths([
        this.lastHistoryUpdate.location.pathname,
        this.lastHistoryUpdate.location.search
      ]) === joinPaths([update.location.pathname, update.location.search]))
        return;
    }
    this.lastHistoryUpdate = update;
    let trailingPathname = stripBasename(update.location.pathname, this.basename);
    if (trailingPathname == null) {
      return;
    }
    const matchedRoutes = this.matchRoutes(trailingPathname);
    if (isNil(matchedRoutes))
      return;
    if (matchedRoutes[matchedRoutes.length - 1].route.redirect) {
      this.navigate(matchedRoutes[matchedRoutes.length - 1].route.redirect, {
        replace: true
      });
      return;
    }
    const location = {
      pathname: trailingPathname,
      search: update.location.search,
      hash: update.location.hash,
      state: update.location.state,
      key: update.location.key,
      action: update.action,
      matched: matchedRoutes,
      meta: matchedRoutes.reduce((pre, cur) => Object.assign(pre, cur.route.meta), {}),
      params: Object.assign({}, (_a = matchedRoutes[matchedRoutes.length - 1]) == null ? void 0 : _a.params)
    };
    const ctx = {
      to: location,
      from: this.location
    };
    await this.execMiddlewares(ctx, [
      ...this.middlewares,
      {
        handler: async ({ to }) => {
          const lastUpdatePathname = stripBasename(this.lastHistoryUpdate.location.pathname, this.basename);
          if (lastUpdatePathname !== to.pathname)
            return;
          this.location = to;
          this.event.emit("onLocationChange", to);
        },
        register: () => true
      }
    ]);
  }
  matchRoutes(pathname) {
    var _a;
    const matchedRoutes = (_a = matchRoutes(this.routes, {
      pathname
    })) == null ? void 0 : _a.map((match) => Object.assign({}, match, {
      params: Object.assign({}, match.params)
    }));
    return matchedRoutes;
  }
  addLocationListener(listener) {
    this.event.on("onLocationChange", listener);
    if (this.location)
      listener(this.location);
    return this;
  }
  removeLocationListener(listener) {
    this.event.remove("onLocationChange", listener);
  }
  rematch() {
    if (this.lastHistoryUpdate) {
      this.onHistoryLocationChange(this.lastHistoryUpdate, true);
    }
  }
  setRoutes(routes) {
    this.routes = routes;
    return this;
  }
  getRoutes() {
    return this.routes;
  }
  navigate(to, opts) {
    var _a, _b;
    if (typeof to === "number") {
      this.history.go(to);
    } else {
      let trailingPathname = stripBasename(this.history.location.pathname, this.basename);
      if (trailingPathname == null) {
        return;
      }
      let matchedRoutes = (_b = (_a = this.location) == null ? void 0 : _a.matched) != null ? _b : this.matchRoutes(trailingPathname);
      if (isNil(matchedRoutes))
        return;
      let path = resolveTo(to, matchedRoutes.map((match) => match.pathnameBase), trailingPathname);
      if (this.basename !== "/") {
        path.pathname = joinPaths([this.basename, path.pathname]);
      }
      const _navigate = (opts == null ? void 0 : opts.replace) ? this.history.replace : this.history.push;
      _navigate(path, opts == null ? void 0 : opts.state);
    }
  }
  back() {
    this.navigate(-1);
  }
}
export { Middleware, Router, Router as default };
