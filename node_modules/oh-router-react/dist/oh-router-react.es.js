var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import { createPath } from "history";
import * as React from "react";
import React__default, { useState, useEffect } from "react";
import { resolveTo, invariant, getToPathname, joinPaths, matchPath, warning } from "oh-router-shared";
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
const RouterContext = React.createContext(null);
const RouteContext = React.createContext({
  outlet: null,
  matches: []
});
const LocationContext = React.createContext(null);
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = React__default, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, g) {
  var b, d = {}, e = null, h = null;
  g !== void 0 && (e = "" + g);
  a.key !== void 0 && (e = "" + a.key);
  a.ref !== void 0 && (h = a.ref);
  for (b in a)
    m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      d[b] === void 0 && (d[b] = a[b]);
  return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
function useHref(to) {
  invariant(useInRouterContext(), `useHref() may be used only in the context of a <RouterView> component.`);
  let {
    basename,
    history
  } = React.useContext(RouterContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return history.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return React.useContext(RouterContext) != null;
}
function useLocation() {
  invariant(useInRouterContext(), `useLocation() may be used only in the context of a <RouterView> component.`);
  return React.useContext(LocationContext);
}
function useNavigationType() {
  invariant(useInRouterContext(), `useNavigationType() may be used only in the context of a <RouterView> component.`);
  return React.useContext(LocationContext).action;
}
function useMatch(pattern) {
  invariant(useInRouterContext(), `useMatch() may be used only in the context of a <RouterView> component.`);
  let {
    pathname
  } = useLocation();
  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);
}
function useNavigate() {
  invariant(useInRouterContext(), `useNavigate() may be used only in the context of a <RouterView> component.`);
  let {
    basename,
    history
  } = React.useContext(RouterContext);
  let {
    matches
  } = React.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  let activeRef = React.useRef(false);
  React.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = React.useCallback((to, options = {}) => {
    warning(activeRef.current, `You should call navigate() in a React.useEffect(), not when your component is first rendered.`);
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      history.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? history.replace : history.push)(path, options.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
const OutletContext = React.createContext(null);
function useOutletContext() {
  return React.useContext(OutletContext);
}
function useOutlet(context) {
  let outlet = React.useContext(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ jsx(OutletContext.Provider, {
      value: context,
      children: outlet
    });
  }
  return outlet;
}
function useParams() {
  const location = useLocation();
  return location.params;
}
function useResolvedPath(to) {
  let {
    matches
  } = React.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
function useLinkClickHandler(to, {
  target,
  replace: replaceProp,
  state
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to);
  return React__default.useCallback((event) => {
    if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
      event.preventDefault();
      let replace = !!replaceProp || createPath(location) === createPath(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}
const Link = React__default.forwardRef(function LinkWithRef(_a, ref) {
  var _b = _a, {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to
  } = _b, rest = __objRest(_b, [
    "onClick",
    "reloadDocument",
    "replace",
    "state",
    "target",
    "to"
  ]);
  let href = useHref(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ jsx("a", __spreadProps(__spreadValues({}, rest), {
    href,
    onClick: handleClick,
    ref,
    target
  }));
});
const NavLink = React__default.forwardRef(function NavLinkWithRef(_c, ref) {
  var _d = _c, {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _d, rest = __objRest(_d, [
    "aria-current",
    "caseSensitive",
    "className",
    "end",
    "style",
    "to",
    "children"
  ]);
  let location = useLocation();
  let path = useResolvedPath(to);
  let locationPathname = location.pathname;
  let toPathname = path.pathname;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /* @__PURE__ */ jsx(Link, __spreadProps(__spreadValues({}, rest), {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to,
    children: typeof children === "function" ? children({
      isActive
    }) : children
  }));
});
function Outlet(props) {
  return useOutlet(props.context);
}
function RouterView({
  router,
  splash
}) {
  const [location, setLocation] = useState();
  useEffect(() => {
    const listener = (_location) => {
      setLocation(_location);
    };
    router.addLocationListener(listener).start();
    return () => router.removeLocationListener(listener);
  }, [router]);
  if (!location)
    return splash;
  return /* @__PURE__ */ jsx(RouterContext.Provider, {
    value: router,
    children: /* @__PURE__ */ jsx(LocationContext.Provider, {
      value: location,
      children: location.matched.reduceRight((outlet, match, index) => {
        return /* @__PURE__ */ jsx(RouteContext.Provider, {
          children: match.route.element !== void 0 ? match.route.element : outlet,
          value: {
            outlet,
            matches: location.matched.slice(0, index + 1)
          }
        });
      }, null)
    })
  });
}
export { Link, NavLink, Outlet, RouterView, useHref, useInRouterContext, useLinkClickHandler, useLocation, useMatch, useNavigate, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath };
